"""
This type stub file was generated by pyright.
"""

import warnings
from collections.abc import Iterable
from dataclasses import dataclass, field
from typing import Generic, TYPE_CHECKING, TypeVar, TypedDict
from .utils import EnvType
from markdown_it import MarkdownIt

"""
class Ruler

Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
[[MarkdownIt#inline]] to manage sequences of functions (rules):

- keep rules in defined order
- assign the name to each rule
- enable/disable rules
- add/replace rules
- allow assign rules to additional named chains (in the same)
- caching lists of active rules

You will not need use this class directly until write plugins. For simple
rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
[[MarkdownIt.use]].
"""
if TYPE_CHECKING:
    ...
class StateBase:
    def __init__(self, src: str, md: MarkdownIt, env: EnvType) -> None:
        ...
    
    @property
    def src(self) -> str:
        ...
    
    @src.setter
    def src(self, value: str) -> None:
        ...
    
    @property
    def srcCharCode(self) -> tuple[int, ...]:
        ...
    


class RuleOptionsType(TypedDict, total=False):
    alt: list[str]
    ...


RuleFuncTv = TypeVar("RuleFuncTv")
@dataclass(slots=True)
class Rule(Generic[RuleFuncTv]):
    name: str
    enabled: bool
    fn: RuleFuncTv = ...
    alt: list[str]


class Ruler(Generic[RuleFuncTv]):
    def __init__(self) -> None:
        ...
    
    def __find__(self, name: str) -> int:
        """Find rule index by name"""
        ...
    
    def __compile__(self) -> None:
        """Build rules lookup cache"""
        ...
    
    def at(self, ruleName: str, fn: RuleFuncTv, options: RuleOptionsType | None = ...) -> None:
        """Replace rule by name with new function & options.

        :param ruleName: rule name to replace.
        :param fn: new rule function.
        :param options: new rule options (not mandatory).
        :raises: KeyError if name not found
        """
        ...
    
    def before(self, beforeName: str, ruleName: str, fn: RuleFuncTv, options: RuleOptionsType | None = ...) -> None:
        """Add new rule to chain before one with given name.

        :param beforeName: new rule will be added before this one.
        :param ruleName: new rule will be added before this one.
        :param fn: new rule function.
        :param options: new rule options (not mandatory).
        :raises: KeyError if name not found
        """
        ...
    
    def after(self, afterName: str, ruleName: str, fn: RuleFuncTv, options: RuleOptionsType | None = ...) -> None:
        """Add new rule to chain after one with given name.

        :param afterName: new rule will be added after this one.
        :param ruleName: new rule will be added after this one.
        :param fn: new rule function.
        :param options: new rule options (not mandatory).
        :raises: KeyError if name not found
        """
        ...
    
    def push(self, ruleName: str, fn: RuleFuncTv, options: RuleOptionsType | None = ...) -> None:
        """Push new rule to the end of chain.

        :param ruleName: new rule will be added to the end of chain.
        :param fn: new rule function.
        :param options: new rule options (not mandatory).

        """
        ...
    
    def enable(self, names: str | Iterable[str], ignoreInvalid: bool = ...) -> list[str]:
        """Enable rules with given names.

        :param names: name or list of rule names to enable.
        :param ignoreInvalid: ignore errors when rule not found
        :raises: KeyError if name not found and not ignoreInvalid
        :return: list of found rule names
        """
        ...
    
    def enableOnly(self, names: str | Iterable[str], ignoreInvalid: bool = ...) -> list[str]:
        """Enable rules with given names, and disable everything else.

        :param names: name or list of rule names to enable.
        :param ignoreInvalid: ignore errors when rule not found
        :raises: KeyError if name not found and not ignoreInvalid
        :return: list of found rule names
        """
        ...
    
    def disable(self, names: str | Iterable[str], ignoreInvalid: bool = ...) -> list[str]:
        """Disable rules with given names.

        :param names: name or list of rule names to enable.
        :param ignoreInvalid: ignore errors when rule not found
        :raises: KeyError if name not found and not ignoreInvalid
        :return: list of found rule names
        """
        ...
    
    def getRules(self, chainName: str = ...) -> list[RuleFuncTv]:
        """Return array of active functions (rules) for given chain name.
        It analyzes rules configuration, compiles caches if not exists and returns result.

        Default chain name is `''` (empty string). It can't be skipped.
        That's done intentionally, to keep signature monomorphic for high speed.

        """
        ...
    
    def get_all_rules(self) -> list[str]:
        """Return all available rule names."""
        ...
    
    def get_active_rules(self) -> list[str]:
        """Return the active rule names."""
        ...
    


