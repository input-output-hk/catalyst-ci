VERSION 0.8

# To ensure all consumers of `catalyst-ci` use the correct upstream,
# the Rust library from Earthly can only be imported in this Earthfile.
# FUNCTIONs or targets in that Earthfile MUST be shimmed here.
# No other earthfile should reference the rust library in the earthly/lib repo.
IMPORT github.com/earthly/lib/rust:3.0.2 AS rust

# Local Earthfile reference imports
IMPORT ./tools AS rust-tools
IMPORT ../../utilities/scripts AS scripts

# cspell: words rustup miri ripgrep stdcfgs toolset depgraph lcov psycopg
# cspell: words TARGETPLATFORM TARGETOS TARGETARCH TARGETVARIANT USERPLATFORM USEROS USERARCH USERVARIANT
# cspell: words findutils fileset

# Base Rustup build container.
# Parameters:
#  * toolchain : The `rust-toolchain` toml file.
rust-base:
    ARG TARGETPLATFORM
    ARG TARGETOS
    ARG TARGETARCH
    ARG TARGETVARIANT
    ARG USERPLATFORM
    ARG USEROS
    ARG USERARCH
    ARG USERVARIANT

    # This is our base Host toolset, and rustup.
    # The ACTUAL version of Rust that will be used, and available targets
    # is controlled by a `rust-toolchain.toml` file when the `SETUP` FUNCTION is run.
    # HOWEVER, It is enforced that the Rust version in `rust-toolchain.toml` MUST match this version.
    FROM rust:1.77.2-alpine3.19

    WORKDIR /root

    # Install necessary packages
    # Expand this list as needed, rather than adding more tools in later containers.
    RUN apk add --no-cache \
            musl-dev \
            mold \
            clang \
            py3-pip \
            py3-rich \
            py3-psycopg \
            ripgrep \
            bash \
            colordiff \
            graphviz \
            fontconfig \
            ttf-liberation \
            findutils

    # Fix up font cache.
    RUN fc-cache -f

    # Make sure we have the clippy linter.
    RUN rustup component add clippy

    # Needed to generate code coverage.
    RUN rustup component add llvm-tools-preview

    # Install a nightly toolchain which matches.
    RUN rustup toolchain install nightly --component miri --component rust-src --component rustfmt --component clippy

    # Preset CARGO_HOME and the application search path.
    ENV CARGO_HOME="$HOME/.cargo"
    ENV PATH="$PATH:$CARGO_HOME/bin"

# Add all tools we use for Rust builds to the base builder image.
rust-base-plus-tools:
    FROM +rust-base

    COPY rust-tools+tool-cargo-nextest/cargo-nextest $CARGO_HOME/bin/cargo-nextest
    COPY rust-tools+tool-cargo-machete/cargo-machete $CARGO_HOME/bin/cargo-machete
    COPY rust-tools+tool-refinery/refinery $CARGO_HOME/bin/refinery
    COPY rust-tools+tool-cargo-deny/cargo-deny $CARGO_HOME/bin/cargo-deny
    COPY rust-tools+tool-cargo-modules/cargo-modules $CARGO_HOME/bin/cargo-modules
    COPY rust-tools+tool-cargo-depgraph/cargo-depgraph $CARGO_HOME/bin/cargo-depgraph
    COPY rust-tools+tool-cargo-llvm-cov/cargo-llvm-cov $CARGO_HOME/bin/cargo-llvm-cov
    COPY rust-tools+tool-wasm-tools/wasm-tools $CARGO_HOME/bin/wasm-tools
    COPY rust-tools+tool-cargo-expand/cargo-expand $CARGO_HOME/bin/cargo-expand
    COPY rust-tools+tool-wit-bindgen-cli/wit-bindgen $CARGO_HOME/bin/wit-bindgen
    COPY rust-tools+tool-wasmtime/verify-component-adapter $CARGO_HOME/bin/verify-component-adapter
    COPY rust-tools+tool-cargo-sweep/cargo-sweep $CARGO_HOME/bin/cargo-sweep


# installer - fully setup our Rust caching.
installer:
    FROM +rust-base-plus-tools

    # Call `+INIT` before copying the source file to avoid installing dependencies every time source code changes. 
    # This parametrization will be used in future calls to functions of the library
    # Init using the common `cat-ci` cache prefix.
    DO rust+INIT --keep_fingerprints=true

    DO rust+SET_CACHE_MOUNTS_ENV

    # Install the default cargo config, and ensure its in the cached CARGO_HOME as well.
    COPY stdcfgs/cargo_config.toml $CARGO_INSTALL_ROOT/config.toml
    DO +EXECUTE --cmd="cp $CARGO_INSTALL_ROOT/config.toml $CARGO_HOME/config.toml"

    # Universal build scripts.
    # We will always need and are not target dependent.
    COPY --dir scripts /scripts
    # Copy our common scripts so we can use them inside the container.
    DO scripts+ADD_BASH_SCRIPTS
    DO scripts+ADD_PYTHON_SCRIPTS

    # Standardized Rust configs.
    # Build will refuse to proceed if the projects Rust configs do not match these.
    # This is to enforce consistent compiler and tool configuration on local setup and CI builds.
    COPY --dir stdcfgs /stdcfgs

# Builds all the rust-base targets for each supported DOCKER architecture.
# Currently only used for multi-platform cross build testing.
# This will ONLY work if you have `qemu` properly setup on linux and `rosetta` for
# docker enabled on Mac.
# Again, this is just a test target, and not for general use.
rust-base-all-hosts:
    BUILD --platform=linux/amd64 --platform=linux/arm64 +installer

# EXECUTE runs the given command "$cmd".
# This function is thread safe. Parallel builds of targets calling this function should be free of race conditions.
# Notice that in order to run this function, +INIT must be called first.
# Arguments:
#   - cmd: Command and its arguments. Required.
#   - output: Regex matching output artifacts files to be copied to ./target folder in the caller filesystem (image layers).
#     Use this argument when you want to SAVE an ARTIFACT from the target folder (mounted cache), always trying to minimize the total size of the copied fileset.
#     For example --output="release/[^\./]+" would keep all the files in /target/release that don't have any extension.
#   - junit: Filename to save the junit.xml file LOCALLY.
#            Also saves the junit.xml file in the target layer.
#            If not defined, "junit.xml" will not be saved, and will not be in the layer.
#   - coverage: Filename to save the coverage-report.info as LOCALLY
#            If not defined, "coverage-report.info" will not be saved, but will be in the layer.
#
# This is heavily based off of the rust `CARGO` command in the Earthly library.
# Updates to that library must be reflected in this function when updating the version of the earthly rust library.
EXECUTE:
    FUNCTION
    DO rust+CHECK_INITED
    ARG --required cmd
    ARG output
    ARG junit
    ARG coverage
    ARG docs="false"
    ARG ALLOW_DEBUG_TARGET="false"
    DO rust+SET_CACHE_MOUNTS_ENV
    IF [ "$EARTHLY_KEEP_FINGERPRINTS" = "false" ]
       DO rust+REMOVE_SOURCE_FINGERPRINTS
    END

    # target/debug should not be present, so purge it just in case.
    IF [ "$ALLOW_DEBUG_TARGET" != "true" ]
        RUN --mount=$EARTHLY_RUST_CARGO_HOME_CACHE --mount=$EARTHLY_RUST_TARGET_CACHE \
            set -e; \
            rm -rf target/debug;
    END

    # This uses a workaround to TRY/FINALLY not working inside a FUNCTION.
    # The command is executed and a "fail" file is created ONLY if it fails.
    # We then check the existence of the "fail" file after any artifacts are saved that
    # should be saved regardless.
    RUN --mount=$EARTHLY_RUST_CARGO_HOME_CACHE --mount=$EARTHLY_RUST_TARGET_CACHE \
        env | grep EARTHLY; \
        set -e; \
        rm -f fail; \
        $cmd || echo fail > fail; \
        cargo sweep -r -t $EARTHLY_SWEEP_DAYS; \
        cargo sweep -r -i;

    # We always want to save these (if requested) even if the command fails.
    IF [ "$junit" != "" ]
        DO rust+COPY_OUTPUT --output="nextest/ci/junit.xml"
        SAVE ARTIFACT target/nextest/ci/junit.xml AS LOCAL "$junit"
    END
    IF [ "$coverage" != "" ]
        SAVE ARTIFACT coverage-report.info AS LOCAL "$coverage"
    END

    # Defer the failure to here.
    IF [ -f fail ]
        RUN echo "Error on +EXECUTE: $cmd"
        RUN exit 1
    END

    IF [ "$ALLOW_DEBUG_TARGET" != "true" ]
        RUN --mount=$EARTHLY_RUST_CARGO_HOME_CACHE --mount=$EARTHLY_RUST_TARGET_CACHE \
            if [ -d target/debug ]; then \
                echo "Error: 'target/debug' should not be built in CI.  Failing."; \
                exit 1; \
            fi;
    END

    IF [ "$docs" != "false" ]
        DO rust+COPY_OUTPUT --output="doc/.*"
        SAVE ARTIFACT target/doc doc
    END

    # This output is ONLY saved on successful command execution.
    IF [ "$output" != "" ]
        DO rust+COPY_OUTPUT --output=$output
    END

# Shim so we use the correct upstream RUST library consistently
# without having to import it into consuming Earthfiles.
# By default this will NOT expose docs built during the execution of cargo
CARGO:
    FUNCTION

    ARG --required args
    ARG output
    ARG ALLOW_DEBUG_TARGET="false"
    ARG docs="false"

    DO +EXECUTE \
        --cmd="cargo $args" \
        --output="$output" \
        --junit="$junit" \
        --coverage="$coverage" \
        --ALLOW_DEBUG_TARGET="$ALLOW_DEBUG_TARGET" \
        --docs="$docs"

# COPY_OUTPUT copies files out of the target cache into the image layers.
#
# This is a shim which MUST be used by projects consuming catalyst-ci rather than using the 
# upstream earthly rust library directly.
#
# Use this FUNCTION when you want to SAVE an ARTIFACT from the target folder (mounted cache), always trying to minimize the total size of the copied fileset.
# Notice that in order to run this FUNCTION, +SET_CACHE_MOUNTS_ENV or +CARGO must be called first.
# Arguments:
#   - output: Regex matching output artifacts files to be copied to ./target folder in the caller filesystem (image layers).
# Example:
#   DO rust+SET_CACHE_MOUNTS_ENV
#   RUN --mount=$EARTHLY_RUST_CARGO_HOME_CACHE --mount=$EARTHLY_RUST_TARGET_CACHE cargo build --release
#   DO rust+COPY_OUTPUT --output="release/[^\./]+" # Keep all the files in /target/release that don't have any extension.
COPY_OUTPUT:
    FUNCTION
    ARG --required output
    ARG TMP_FOLDER="/tmp/earthly/lib/rust"

    DO rust+COPY_OUTPUT --output=$output --TMP_FOLDER=$TMP_FOLDER

# Common Rust setup.
# Parameters:
#  * toolchain : The `rust-toolchain` toml file.
SETUP:
    FUNCTION
    FROM +installer

    ARG toolchain=./rust-toolchain.toml 

    # Copy our toolchain dependency.
    COPY $toolchain ./rust-toolchain.toml

    # Toolchain MUST be the same as vendored, and if it is the toolchain is
    # already installed.