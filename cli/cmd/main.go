package main

// cspell: words alecthomas afero sess tfstate

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"text/template"
	"time"

	"github.com/alecthomas/kong"
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/input-output-hk/catalyst-ci/cli/pkg/executors"
	"github.com/input-output-hk/catalyst-ci/cli/pkg/git"
	"github.com/input-output-hk/catalyst-ci/cli/pkg/parsers"
	"github.com/input-output-hk/catalyst-ci/cli/pkg/providers"
	"github.com/input-output-hk/catalyst-ci/cli/pkg/scanners"
	"github.com/input-output-hk/catalyst-ci/cli/pkg/util"
	"github.com/spf13/afero"
)

// TagTemplate is a template for generating image tags.
type TagTemplate struct {
	Hash      string
	Timestamp string
	Version   string
}

var cli struct {
	Images   imagesCmd   `cmd:"" help:"Find the images generated by an Earthfile target."`
	Scan     scanCmd     `cmd:"" help:"Scan for Earthfiles."`
	State    stateCmd    `cmd:"" help:"Fetch outputs from remote Terraform state buckets."`
	Tags     tagsCmd     `cmd:"" help:"Generate image tags with the current git context."`
	Simulate simulateCmd `cmd:"" help:"Simulate earthly commands."`
	Generate generateCmd `cmd:"" help:"Generate Earthfile from the given targets"`
}

type imagesCmd struct {
	JSONOutput bool   `short:"j" long:"json" help:"Output in JSON format"`
	Path       string `                      help:"path to Earthfile"               arg:"" type:"path"`
	Target     string `short:"t"             help:"The target to search for images"                    required:"true"`
}

func (c *imagesCmd) Run() error {
	parser := parsers.NewEarthlyParser()
	earthfile, err := parser.Parse(c.Path)
	if err != nil {
		return err
	}

	images, err := earthfile.GetImages(c.Target)
	if err != nil {
		return err
	}

	if c.JSONOutput {
		jsonImages, err := json.Marshal(images)
		if err != nil {
			return err
		}
		fmt.Println(string(jsonImages))
		return nil
	}

	for _, image := range images {
		fmt.Println(image)
	}

	return nil
}

type scanCmd struct {
	JSONOutput bool     `short:"j" long:"json"   help:"Output in JSON format"`
	Paths      []string `                        help:"paths to scan for Earthfiles"                                             arg:"" type:"path"`
	Targets    []string `short:"t"               help:"filter by Earthfiles that include this targets pattern"                                               default:""`
}

func (c *scanCmd) Run() error {
	parser := parsers.NewEarthlyParser()
	scanner := scanners.NewFileScanner(c.Paths, parser, afero.NewOsFs())

	var err error
	// Target tag is set.
	if len(c.Targets) != 0 {
		var fileMapTarget = make(map[string][]string)
		for _, t := range c.Targets {
			pathToEarthMap, err := scanner.ScanForTarget(t)

			if err != nil {
				return err
			}

			for key, value := range pathToEarthMap {
				if existingTargets, ok := fileMapTarget[filepath.Dir(key)]; ok {
					fileMapTarget[filepath.Dir(key)] = append(existingTargets, value.Targets...)
				} else {
					fileMapTarget[filepath.Dir(key)] = value.Targets
				}
			}
		}

		err = c.printOutput(fileMapTarget)
		if err != nil {
			return err
		}

	} else {
		files, err := scanner.Scan()
		if err != nil {
			return err
		}
		paths := make([]string, 0)
		for _, file := range files {
			paths = append(paths, filepath.Dir(file.Path))
		}

		err = c.printOutput(paths)
		if err != nil {
			return err
		}
	}

	return nil
}

func (c *scanCmd) printOutput(data interface{}) error {
	if c.JSONOutput {
		jsonOutput, err := json.Marshal(data)
		if err != nil {
			return err
		}
		fmt.Println(string(jsonOutput))
		return nil
	}
	fmt.Println(data)
	return nil
}

type stateCmd struct {
	Bucket      string `short:"b" long:"bucket"      help:"S3 bucket that state is stored in"         env:"CI_STATE_BUCKET" required:"true"`
	Environment string `short:"e" long:"environment" help:"The target environment to fetch state for" env:"CI_ENVIRONMENT"  required:"true"`
	Key         string `                             help:"key to fetch"                                                    required:"true" arg:""`
	Output      string `short:"o" long:"output"      help:"The name of the output to return"`
}

func (c *stateCmd) Run() error {
	// Load AWS credentials from the default profile.
	sess := session.Must(session.NewSessionWithOptions(session.Options{
		SharedConfigState: session.SharedConfigEnable,
	}))

	provider := providers.NewRemoteStateProvider(sess)
	key := path.Join(c.Environment, c.Key, "terraform.tfstate")

	state, err := provider.Fetch(c.Bucket, key)
	if err != nil {
		return err
	}

	var result string
	if c.Output == "" {
		outputs, err := json.Marshal(state.Outputs)
		if err != nil {
			return err
		}

		result = string(outputs)
	} else {
		if _, ok := state.Outputs[c.Output]; !ok {
			return fmt.Errorf("output %s not found", c.Output)
		}

		outputs, err := json.Marshal(state.Outputs[c.Output])
		if err != nil {
			return err
		}

		result = string(outputs)
	}

	fmt.Println(result)

	return nil
}

type tagsCmd struct {
	TemplateString string `arg:"" help:"template for generating image tags" default:"{{ .Hash }}"`
}

func (c *tagsCmd) Run() error {
	executor := executors.NewLocalExecutor("git")
	client := git.NewExternalGitClient(executor)

	// Collect the highest version from the git tags
	tags, err := client.Tags()
	if err != nil {
		return err
	}
	highest := util.GetHighestVersion(tags)

	// Get the current git commit hash
	hash, err := executor.Run("rev-parse", "HEAD")
	if err != nil {
		return err
	}

	// Get the current timestamp
	timestamp := time.Now().Format("20060102150405")

	// Generate the tag
	tmpl, err := template.New("tag").Parse(c.TemplateString)
	if err != nil {
		return err
	}

	data := TagTemplate{
		Hash:      hash,
		Timestamp: timestamp,
		Version:   highest,
	}
	err = tmpl.Execute(os.Stdout, data)
	if err != nil {
		return err
	}

	return nil
}

type simulateCmd struct {
	Path    string   `                      help:"directory path to be iterated to search for targets within the Earthfile"               arg:"" type:"path"`
	Targets []string `short:"t"               help:"Earthly targets pattern"                                               default:"check,check-*,build,test,test-*"`
}

func (c *simulateCmd) Run() error {
	parser := parsers.NewEarthlyParser()
	scanner := scanners.NewFileScanner([]string{c.Path}, parser, afero.NewOsFs())

	// Loop through target patterns.
	for _, tp := range c.Targets {
		err := processTargets(scanner, tp, "", func(target string) {
			fmt.Println(">>> Running target", target)
			runEarthlyTarget(target)
		})
		if err != nil {
			return err
		}
	}
	return nil
}

// Run Earthly with target and print out logs.
func runEarthlyTarget(earthlyCmd string) {
	command := "earthly"

	// Create the command.
	cmd := exec.Command(command, earthlyCmd)

	var stdoutBuf, stderrBuf bytes.Buffer
	cmd.Stdout = io.MultiWriter(os.Stdout, &stdoutBuf)
	cmd.Stderr = io.MultiWriter(os.Stderr, &stderrBuf)

	err := cmd.Run()
	if err != nil {
		log.Fatalf("cmd.Run() failed with %s\n", err)
	}
	outStr, errStr := stdoutBuf.String(), stderrBuf.String()
	fmt.Printf("\nout:\n%s\nerr:\n%s\n", outStr, errStr)
}

type generateCmd struct {
	Path    string   `                      help:"directory path to be iterated to search for targets within the Earthfile"               arg:"" type:"path"`
	Targets []string `short:"t"             help:"Earthly targets pattern"                                               default:"check,check-*,build,test,test-*"`
	Version string   `short:"v"             help:"Earthly version"                    default:"0.7"`
}

// Generate Earthfile with given targets.
// All targets associated with the given targets will be listed inside.
func (c *generateCmd) Run() error {
	directory := "generate"
	// Create a directory generate with an Earthfile.
	writer, err := createFile(directory, "Earthfile")
	if err != nil {
		return err
	}
	// Write down Earthly version and main target.
	setup := fmt.Sprintf("VERSION --global-cache %s \nsimulate:\n", c.Version)
	_, err = writer.WriteString(setup)
	if err != nil {
		return err
	}

	parser := parsers.NewEarthlyParser()
	scanner := scanners.NewFileScanner([]string{c.Path}, parser, afero.NewOsFs())
	for _, tp := range c.Targets {
		err = processTargets(scanner, tp, directory, func(target string) {
			data := fmt.Sprintf("\t BUILD %s\n", target)
			fmt.Println(">>> Target with Path", data)
			_, err = writer.WriteString(data)
			if err != nil {
				fmt.Println("Error writing to file:", err)
			}
		})
		if err != nil {
			return err
		}
		err = writer.Flush()
		if err != nil {
			return err
		}
	}
	return nil
}

// Create file with given file name and directory.
func createFile(directory string, fileName string) (*bufio.Writer, error) {
	// Create directory
	err := os.MkdirAll(directory, os.ModePerm)
	if err != nil {
		return nil, err
	}

	filePath := filepath.Join(directory, fileName)
	file, err := os.Create(filePath)
	if err != nil {
		return nil, err
	}

	writer := bufio.NewWriter(file)

	return writer, nil
}

// Scans for targets using the given target pattern
// then called the callback for each target.
func processTargets(scanner *scanners.FileScanner, targetPattern string, directory string, callback func(target string)) error {
	fmt.Println(">>>>>>> Detecting", targetPattern, "target")
	pathToEarthMap, err := scanner.ScanForTarget(targetPattern)
	if err != nil {
		return err
	}

	curDir, err := os.Getwd()
	if err != nil {
		return err
	}

	filePath := filepath.Join(curDir, directory)

	// Loop through filtered targets.
	for _, e := range pathToEarthMap {
		for _, tg := range e.Targets {
			// Get relative target path.
			relativePath, err := filepath.Rel(filePath, e.Earthfile.Path)
			if err != nil {
				return err
			}

			target := filepath.Join(filepath.Dir(relativePath), "+"+tg)
			callback(target)
		}
	}
	return nil
}

func main() {
	ctx := kong.Parse(&cli)
	err := ctx.Run()
	ctx.FatalIfErrorf(err)
	os.Exit(0)
}
